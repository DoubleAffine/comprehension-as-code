---
phase: 02-bayesian-update
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/comprehension/update/lifecycle.py
  - src/comprehension/update/__init__.py
  - tests/test_lifecycle.py
autonomous: true

must_haves:
  truths:
    - "Observations have explicit lifecycle states: PENDING, INCORPORATED, COLLECTIBLE"
    - "Observations can be marked as incorporated after informing comprehension"
    - "Incorporated observations are collectible for garbage collection"
    - "Lifecycle manager tracks observation state transitions"
  artifacts:
    - path: "src/comprehension/update/lifecycle.py"
      provides: "Observation lifecycle management"
      exports: ["ObservationState", "ObservationLifecycle"]
    - path: "tests/test_lifecycle.py"
      provides: "Test coverage for lifecycle management"
      min_lines: 40
  key_links:
    - from: "src/comprehension/update/__init__.py"
      to: "src/comprehension/update/lifecycle.py"
      via: "re-export"
      pattern: "from .lifecycle import"
---

<objective>
Implement observation lifecycle management for garbage collection support.

Purpose: Observations are ephemeral - once they've informed comprehension, they can be discarded. The lifecycle manager tracks observation states (PENDING -> INCORPORATED -> COLLECTIBLE) to enable memory-efficient operation. This supports the core principle: "store beliefs, not evidence."

Output: `ObservationState` enum and `ObservationLifecycle` class that tracks which observations are safe to garbage collect.
</objective>

<execution_context>
@/Users/ianphilipp/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ianphilipp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bayesian-update/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ObservationState enum and ObservationLifecycle class</name>
  <files>src/comprehension/update/lifecycle.py</files>
  <action>
Create `src/comprehension/update/lifecycle.py`:

```python
"""Observation lifecycle management for garbage collection.

Key insight: Once an observation has informed comprehension, the observation
itself can be discarded. The posterior IS the compression - we store beliefs,
not evidence.
"""

from enum import Enum
from typing import Set


class ObservationState(str, Enum):
    """Lifecycle states for observations.

    PENDING: Created, not yet incorporated into any comprehension
    INCORPORATED: Has informed at least one comprehension
    COLLECTIBLE: Safe to garbage collect (same as INCORPORATED for now)

    Note: Currently INCORPORATED == COLLECTIBLE. Future phases may add
    retention policies (e.g., keep for N days, keep if referenced by
    active comprehension, etc.)
    """
    PENDING = "pending"
    INCORPORATED = "incorporated"
    COLLECTIBLE = "collectible"


class ObservationLifecycle:
    """Manages observation lifecycle for garbage collection.

    Tracks observation state transitions:
    - register(): New observation -> PENDING
    - mark_incorporated(): PENDING -> INCORPORATED
    - get_collectible(): Returns IDs safe for deletion
    - collect(): Acknowledge deletion, stop tracking

    Thread safety: NOT thread-safe. Wrap in lock for concurrent access.
    """

    def __init__(self):
        """Initialize empty lifecycle tracker."""
        self._pending: Set[str] = set()
        self._incorporated: Set[str] = set()

    def register(self, observation_id: str) -> None:
        """Register new observation as pending.

        Args:
            observation_id: Unique identifier for the observation
        """
        self._pending.add(observation_id)

    def mark_incorporated(self, observation_id: str) -> None:
        """Mark observation as having informed a comprehension.

        Moves observation from PENDING to INCORPORATED state.
        Can be called multiple times (idempotent).

        Args:
            observation_id: Observation that has been incorporated
        """
        self._pending.discard(observation_id)
        self._incorporated.add(observation_id)

    def get_state(self, observation_id: str) -> ObservationState:
        """Get current state of an observation.

        Args:
            observation_id: Observation to check

        Returns:
            ObservationState or raises KeyError if not tracked
        """
        if observation_id in self._pending:
            return ObservationState.PENDING
        if observation_id in self._incorporated:
            return ObservationState.INCORPORATED
        raise KeyError(f"Unknown observation: {observation_id}")

    def get_pending(self) -> Set[str]:
        """Get observation IDs that haven't been incorporated yet.

        Returns:
            Set of observation IDs in PENDING state
        """
        return self._pending.copy()

    def get_collectible(self) -> Set[str]:
        """Get observation IDs safe for garbage collection.

        Returns observations that have been incorporated into at least
        one comprehension's posterior. Their content is now redundant.

        Returns:
            Set of observation IDs safe to delete
        """
        return self._incorporated.copy()

    def collect(self, observation_id: str) -> bool:
        """Remove observation from tracking after deletion.

        Call this after successfully deleting the observation file/record.

        Args:
            observation_id: Observation that was deleted

        Returns:
            True if observation was collectible and removed, False otherwise
        """
        if observation_id in self._incorporated:
            self._incorporated.remove(observation_id)
            return True
        return False

    def is_pending(self, observation_id: str) -> bool:
        """Check if observation is pending (not yet incorporated)."""
        return observation_id in self._pending

    def is_incorporated(self, observation_id: str) -> bool:
        """Check if observation has been incorporated."""
        return observation_id in self._incorporated

    def __len__(self) -> int:
        """Total number of tracked observations."""
        return len(self._pending) + len(self._incorporated)

    def stats(self) -> dict:
        """Get lifecycle statistics.

        Returns:
            Dict with counts: pending, incorporated, total
        """
        return {
            "pending": len(self._pending),
            "incorporated": len(self._incorporated),
            "total": len(self),
        }
```
  </action>
  <verify>
- `python -c "from comprehension.update.lifecycle import ObservationState, ObservationLifecycle; print('OK')"`
- `python -c "from comprehension.update.lifecycle import ObservationState; print(ObservationState.PENDING.value)"`
  </verify>
  <done>ObservationState and ObservationLifecycle classes exist and are importable</done>
</task>

<task type="auto">
  <name>Task 2: Add tests and update exports</name>
  <files>tests/test_lifecycle.py, src/comprehension/update/__init__.py</files>
  <action>
Create `tests/test_lifecycle.py`:

```python
"""Tests for observation lifecycle management."""

import pytest

from comprehension.update.lifecycle import ObservationState, ObservationLifecycle


class TestObservationState:
    """ObservationState enum has expected values."""

    def test_pending_exists(self):
        assert ObservationState.PENDING.value == "pending"

    def test_incorporated_exists(self):
        assert ObservationState.INCORPORATED.value == "incorporated"

    def test_collectible_exists(self):
        assert ObservationState.COLLECTIBLE.value == "collectible"


class TestLifecycleBasics:
    """Basic lifecycle operations."""

    def test_register_observation(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        assert lifecycle.is_pending("obs-001")
        assert not lifecycle.is_incorporated("obs-001")

    def test_mark_incorporated(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        lifecycle.mark_incorporated("obs-001")
        assert not lifecycle.is_pending("obs-001")
        assert lifecycle.is_incorporated("obs-001")

    def test_mark_incorporated_idempotent(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        lifecycle.mark_incorporated("obs-001")
        lifecycle.mark_incorporated("obs-001")  # Should not fail
        assert lifecycle.is_incorporated("obs-001")


class TestGetState:
    """State retrieval."""

    def test_get_pending_state(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        assert lifecycle.get_state("obs-001") == ObservationState.PENDING

    def test_get_incorporated_state(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        lifecycle.mark_incorporated("obs-001")
        assert lifecycle.get_state("obs-001") == ObservationState.INCORPORATED

    def test_unknown_observation_raises(self):
        lifecycle = ObservationLifecycle()
        with pytest.raises(KeyError):
            lifecycle.get_state("obs-unknown")


class TestGarbageCollection:
    """Garbage collection support."""

    def test_pending_not_collectible(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        assert "obs-001" not in lifecycle.get_collectible()

    def test_incorporated_is_collectible(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        lifecycle.mark_incorporated("obs-001")
        assert "obs-001" in lifecycle.get_collectible()

    def test_collect_removes_from_tracking(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        lifecycle.mark_incorporated("obs-001")

        result = lifecycle.collect("obs-001")

        assert result is True
        assert "obs-001" not in lifecycle.get_collectible()
        assert not lifecycle.is_incorporated("obs-001")

    def test_collect_pending_returns_false(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        result = lifecycle.collect("obs-001")
        assert result is False
        assert lifecycle.is_pending("obs-001")


class TestBulkOperations:
    """Operations on multiple observations."""

    def test_get_pending_returns_copy(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        pending = lifecycle.get_pending()
        pending.add("obs-999")  # Modify returned set
        assert "obs-999" not in lifecycle.get_pending()

    def test_get_collectible_returns_copy(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        lifecycle.mark_incorporated("obs-001")
        collectible = lifecycle.get_collectible()
        collectible.add("obs-999")  # Modify returned set
        assert "obs-999" not in lifecycle.get_collectible()


class TestStats:
    """Lifecycle statistics."""

    def test_empty_stats(self):
        lifecycle = ObservationLifecycle()
        stats = lifecycle.stats()
        assert stats["pending"] == 0
        assert stats["incorporated"] == 0
        assert stats["total"] == 0

    def test_stats_after_operations(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        lifecycle.register("obs-002")
        lifecycle.mark_incorporated("obs-001")

        stats = lifecycle.stats()
        assert stats["pending"] == 1
        assert stats["incorporated"] == 1
        assert stats["total"] == 2

    def test_len(self):
        lifecycle = ObservationLifecycle()
        lifecycle.register("obs-001")
        lifecycle.register("obs-002")
        assert len(lifecycle) == 2
```

Update `src/comprehension/update/__init__.py` to include lifecycle exports:

```python
from .confidence_rules import (
    EvidenceType,
    compute_confidence_transition,
    CONFIDENCE_TRANSITIONS,
)
from .lifecycle import ObservationState, ObservationLifecycle

__all__ = [
    "EvidenceType",
    "compute_confidence_transition",
    "CONFIDENCE_TRANSITIONS",
    "ObservationState",
    "ObservationLifecycle",
]
```

Note: bayesian_update will be added to this file in Plan 02-02.
  </action>
  <verify>
- `pytest tests/test_lifecycle.py -v` - all tests pass
- `python -c "from comprehension.update import ObservationState, ObservationLifecycle; print('OK')"`
  </verify>
  <done>Lifecycle tests pass and module exports are complete</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_lifecycle.py -v` - all tests pass
2. `python -c "from comprehension.update import ObservationState, ObservationLifecycle"` - imports work
3. Lifecycle states: PENDING -> INCORPORATED -> (garbage collected)
4. `get_collectible()` returns only incorporated observations
5. `collect()` removes observation from tracking after deletion
</verification>

<success_criteria>
- [ ] ObservationState enum exists with PENDING, INCORPORATED, COLLECTIBLE
- [ ] ObservationLifecycle class exists with register, mark_incorporated, get_collectible, collect methods
- [ ] Pending observations are NOT collectible
- [ ] Incorporated observations ARE collectible
- [ ] collect() removes observation from tracking
- [ ] get_pending() and get_collectible() return defensive copies
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-bayesian-update/02-03-SUMMARY.md`
</output>
