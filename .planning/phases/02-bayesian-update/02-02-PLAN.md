---
phase: 02-bayesian-update
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/comprehension/update/bayesian_update.py
  - src/comprehension/update/__init__.py
  - tests/test_bayesian_update.py
autonomous: true

must_haves:
  truths:
    - "Given observation + comprehension, new posterior is computed"
    - "Posterior includes observation ID in provenance (observations_used)"
    - "Applying same observation twice returns unchanged comprehension (idempotent)"
    - "Contradicting evidence requires new belief statement (enforced)"
    - "The update operation produces a new Comprehension, not mutation"
  artifacts:
    - path: "src/comprehension/update/bayesian_update.py"
      provides: "Core Bayesian update function"
      exports: ["bayesian_update"]
    - path: "tests/test_bayesian_update.py"
      provides: "Test coverage for update operation"
      min_lines: 80
  key_links:
    - from: "src/comprehension/update/bayesian_update.py"
      to: "src/comprehension/update/confidence_rules.py"
      via: "import"
      pattern: "from.*confidence_rules import.*compute_confidence_transition"
    - from: "src/comprehension/update/bayesian_update.py"
      to: "src/comprehension/schema/comprehension.py"
      via: "import"
      pattern: "from.*schema.*import Comprehension"
    - from: "src/comprehension/update/bayesian_update.py"
      to: "src/comprehension/schema/observation.py"
      via: "import"
      pattern: "from.*schema.*import Observation"
---

<objective>
Implement the core Bayesian update operation: `bayesian_update(observation, comprehension, evidence_type) -> Comprehension`.

Purpose: This IS the compression operation. The new posterior encodes what the observation taught, allowing the observation to be garbage collected afterward. This function is the heart of Phase 2.

Output: Pure function `bayesian_update()` that produces a new Comprehension with updated posterior, provenance tracking, version increment, and timestamp update.
</objective>

<execution_context>
@/Users/ianphilipp/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ianphilipp/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bayesian-update/02-RESEARCH.md
@src/comprehension/schema/comprehension.py
@src/comprehension/schema/observation.py
@src/comprehension/update/confidence_rules.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for bayesian_update</name>
  <files>tests/test_bayesian_update.py</files>
  <action>
Create `tests/test_bayesian_update.py` with comprehensive tests BEFORE implementation:

```python
"""Tests for the core Bayesian update operation."""

import pytest
from datetime import datetime, timezone

from comprehension.schema import (
    Comprehension, Observation, BeliefPrior, BeliefPosterior, ConfidenceLevel
)
from comprehension.update import EvidenceType
from comprehension.update.bayesian_update import bayesian_update


@pytest.fixture
def sample_observation():
    """Create a sample observation for testing."""
    return Observation(
        id="obs-test-001",
        timestamp=datetime.now(timezone.utc),
        source="test-agent",
        event="Observed that API returns 200 on valid request",
        context={"endpoint": "/api/test"},
    )


@pytest.fixture
def sample_comprehension():
    """Create a sample comprehension for testing."""
    now = datetime.now(timezone.utc)
    return Comprehension(
        id="comp-test-001",
        topic="API response behavior",
        domain="api",
        prior=BeliefPrior(
            statement="API should return 200 on valid requests",
            confidence=ConfidenceLevel.LOW,
            source="documentation",
        ),
        observations=[],
        posterior=BeliefPosterior(
            statement="API should return 200 on valid requests",
            confidence=ConfidenceLevel.LOW,
            update_reasoning="Initial belief from documentation",
            observations_used=[],
        ),
        created=now,
        updated=now,
        version=1,
    )


class TestBasicUpdate:
    """Basic update operation produces new comprehension."""

    def test_returns_new_comprehension(self, sample_observation, sample_comprehension):
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )
        # Must return Comprehension, not modify in place
        assert isinstance(result, Comprehension)
        assert result is not sample_comprehension

    def test_increments_version(self, sample_observation, sample_comprehension):
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )
        assert result.version == sample_comprehension.version + 1

    def test_updates_timestamp(self, sample_observation, sample_comprehension):
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )
        assert result.updated >= sample_comprehension.updated


class TestProvenanceTracking:
    """Provenance tracks which observations informed belief."""

    def test_observation_id_in_observations_list(self, sample_observation, sample_comprehension):
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )
        assert sample_observation.id in result.observations

    def test_observation_id_in_posterior_observations_used(self, sample_observation, sample_comprehension):
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )
        assert sample_observation.id in result.posterior.observations_used

    def test_preserves_existing_observations(self, sample_observation, sample_comprehension):
        # Add a prior observation
        prior_obs_id = "obs-prior-001"
        comp_with_prior = sample_comprehension.model_copy(update={
            "observations": [prior_obs_id],
            "posterior": sample_comprehension.posterior.model_copy(update={
                "observations_used": [prior_obs_id],
            }),
        })

        result = bayesian_update(
            observation=sample_observation,
            comprehension=comp_with_prior,
            evidence_type=EvidenceType.CONFIRMING,
        )

        assert prior_obs_id in result.observations
        assert sample_observation.id in result.observations
        assert prior_obs_id in result.posterior.observations_used
        assert sample_observation.id in result.posterior.observations_used


class TestIdempotency:
    """Same observation applied twice returns unchanged comprehension."""

    def test_idempotent_update(self, sample_observation, sample_comprehension):
        # First update
        first_result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )

        # Second update with same observation
        second_result = bayesian_update(
            observation=sample_observation,
            comprehension=first_result,
            evidence_type=EvidenceType.CONFIRMING,
        )

        # Should be unchanged (same object or equal)
        assert second_result.version == first_result.version
        assert second_result.observations == first_result.observations

    def test_idempotent_no_duplicate_in_observations(self, sample_observation, sample_comprehension):
        first_result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )

        second_result = bayesian_update(
            observation=sample_observation,
            comprehension=first_result,
            evidence_type=EvidenceType.CONFIRMING,
        )

        # Observation ID should appear exactly once
        assert second_result.observations.count(sample_observation.id) == 1


class TestConfidenceTransitions:
    """Update uses confidence transition rules."""

    def test_confirming_increases_confidence(self, sample_observation, sample_comprehension):
        # sample_comprehension starts at LOW
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )
        assert result.posterior.confidence == ConfidenceLevel.MEDIUM

    def test_contradicting_decreases_confidence(self, sample_observation):
        # Start with HIGH confidence
        now = datetime.now(timezone.utc)
        high_confidence_comp = Comprehension(
            id="comp-test-high",
            topic="Test topic",
            domain="test",
            prior=BeliefPrior(
                statement="Original belief",
                confidence=ConfidenceLevel.HIGH,
                source="test",
            ),
            observations=[],
            posterior=BeliefPosterior(
                statement="Original belief",
                confidence=ConfidenceLevel.HIGH,
                update_reasoning="Prior high confidence",
                observations_used=[],
            ),
            created=now,
            updated=now,
        )

        result = bayesian_update(
            observation=sample_observation,
            comprehension=high_confidence_comp,
            evidence_type=EvidenceType.CONTRADICTING,
            new_statement="Updated belief after contradiction",
        )
        assert result.posterior.confidence == ConfidenceLevel.MEDIUM


class TestContradictingEvidence:
    """Contradicting evidence requires new belief statement."""

    def test_contradicting_requires_new_statement(self, sample_observation, sample_comprehension):
        with pytest.raises(ValueError, match="new.*statement"):
            bayesian_update(
                observation=sample_observation,
                comprehension=sample_comprehension,
                evidence_type=EvidenceType.CONTRADICTING,
                # Missing new_statement
            )

    def test_contradicting_with_new_statement_succeeds(self, sample_observation, sample_comprehension):
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONTRADICTING,
            new_statement="Revised belief after contradicting evidence",
        )
        assert result.posterior.statement == "Revised belief after contradicting evidence"


class TestUpdateReasoning:
    """Update includes reasoning about how observation changed belief."""

    def test_custom_reasoning_preserved(self, sample_observation, sample_comprehension):
        custom_reasoning = "API test confirmed the expected behavior"
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
            update_reasoning=custom_reasoning,
        )
        assert custom_reasoning in result.posterior.update_reasoning

    def test_default_reasoning_generated(self, sample_observation, sample_comprehension):
        result = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )
        # Should have some reasoning even if not provided
        assert len(result.posterior.update_reasoning) > 0
        assert sample_observation.id in result.posterior.update_reasoning


class TestImmutability:
    """Update does not mutate original comprehension."""

    def test_original_unchanged(self, sample_observation, sample_comprehension):
        original_observations = sample_comprehension.observations.copy()
        original_version = sample_comprehension.version

        _ = bayesian_update(
            observation=sample_observation,
            comprehension=sample_comprehension,
            evidence_type=EvidenceType.CONFIRMING,
        )

        assert sample_comprehension.observations == original_observations
        assert sample_comprehension.version == original_version
```

Tests must FAIL because `bayesian_update.py` doesn't exist yet.
  </action>
  <verify>
Run `pytest tests/test_bayesian_update.py -v` and confirm tests FAIL with ImportError.
  </verify>
  <done>Tests written and failing (RED state)</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement bayesian_update function</name>
  <files>src/comprehension/update/bayesian_update.py, src/comprehension/update/__init__.py</files>
  <action>
Create `src/comprehension/update/bayesian_update.py`:

```python
"""Core Bayesian update operation.

This IS the compression operation. The new posterior encodes what the
observation taught, allowing the observation to be garbage collected.
"""

from datetime import datetime, timezone
from typing import Optional

from comprehension.schema import (
    Comprehension, Observation, BeliefPosterior, ConfidenceLevel
)
from comprehension.update.confidence_rules import (
    EvidenceType, compute_confidence_transition
)


def bayesian_update(
    observation: Observation,
    comprehension: Comprehension,
    evidence_type: EvidenceType,
    new_statement: Optional[str] = None,
    update_reasoning: Optional[str] = None,
) -> Comprehension:
    """Apply Bayesian update: observation informs comprehension.

    This IS the compression operation. The new posterior encodes what
    the observation taught, allowing observation GC afterward.

    Args:
        observation: Evidence to incorporate
        comprehension: Current belief state
        evidence_type: How observation relates to belief
        new_statement: Updated belief statement (required if contradicting)
        update_reasoning: Explanation of belief change (auto-generated if not provided)

    Returns:
        New Comprehension with updated posterior

    Raises:
        ValueError: If contradicting evidence but no new statement provided
    """
    # Idempotency check: already incorporated
    if observation.id in comprehension.observations:
        return comprehension

    # Validate: contradicting evidence requires new statement
    if evidence_type == EvidenceType.CONTRADICTING and new_statement is None:
        raise ValueError(
            "Contradicting evidence requires a new belief statement. "
            "Provide new_statement parameter."
        )

    # Compute confidence transition
    old_confidence = comprehension.posterior.confidence
    new_confidence = compute_confidence_transition(old_confidence, evidence_type)

    # Determine final statement
    final_statement = (
        new_statement
        if new_statement is not None
        else comprehension.posterior.statement
    )

    # Build update reasoning if not provided
    if update_reasoning is None:
        update_reasoning = (
            f"Observation {observation.id} ({evidence_type.value}) "
            f"changed confidence from {old_confidence.value} to {new_confidence.value}"
        )

    # Create new posterior (immutable)
    new_posterior = BeliefPosterior(
        statement=final_statement,
        confidence=new_confidence,
        update_reasoning=update_reasoning,
        observations_used=comprehension.posterior.observations_used + [observation.id],
    )

    # Return new comprehension (immutable copy with updates)
    return comprehension.model_copy(update={
        "posterior": new_posterior,
        "observations": comprehension.observations + [observation.id],
        "updated": datetime.now(timezone.utc),
        "version": comprehension.version + 1,
    })
```

Update `src/comprehension/update/__init__.py` to export:

```python
from .confidence_rules import (
    EvidenceType,
    compute_confidence_transition,
    CONFIDENCE_TRANSITIONS,
)
from .bayesian_update import bayesian_update

__all__ = [
    "EvidenceType",
    "compute_confidence_transition",
    "CONFIDENCE_TRANSITIONS",
    "bayesian_update",
]
```
  </action>
  <verify>
Run `pytest tests/test_bayesian_update.py -v` and confirm ALL tests PASS.
  </verify>
  <done>All bayesian_update tests passing (GREEN state)</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_bayesian_update.py -v` - all tests pass
2. `python -c "from comprehension.update import bayesian_update"` - import works
3. Idempotency: applying same observation twice returns unchanged comprehension
4. Provenance: observation ID appears in both `observations` and `posterior.observations_used`
5. Contradicting evidence without new_statement raises ValueError
6. Version increments on each successful update
</verification>

<success_criteria>
- [ ] bayesian_update() function exists and is importable
- [ ] Returns new Comprehension (immutable, not mutation)
- [ ] Increments version on update
- [ ] Updates timestamp on update
- [ ] Adds observation ID to observations list
- [ ] Adds observation ID to posterior.observations_used
- [ ] Idempotent: same observation twice = no change
- [ ] Contradicting evidence requires new_statement (raises ValueError if missing)
- [ ] Confidence transitions use compute_confidence_transition()
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-bayesian-update/02-02-SUMMARY.md`
</output>
